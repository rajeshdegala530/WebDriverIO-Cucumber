"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStepArgument = createStepArgument;
exports.getTestParent = getTestParent;
exports.getTestStepTitle = getTestStepTitle;
exports.getTestFullTitle = getTestFullTitle;
exports.getUniqueIdentifier = getUniqueIdentifier;
exports.formatMessage = formatMessage;
exports.getStepType = getStepType;
exports.buildStepPayload = buildStepPayload;
exports.compareScenarioLineWithSourceLine = compareScenarioLineWithSourceLine;
exports.setUserHookNames = setUserHookNames;
exports.getTestCaseSteps = getTestCaseSteps;
exports.enhanceStepWithPickleData = enhanceStepWithPickleData;
exports.getAllSteps = getAllSteps;
exports.getDataFromResult = void 0;

var path = _interopRequireWildcard(require("path"));

var _utils = require("@wdio/utils");

var _constants = require("./constants");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createStepArgument({
  argument
}) {
  if (!argument) {
    return undefined;
  }

  if (argument.type === 'DataTable') {
    return {
      rows: argument.rows.map(row => ({
        cells: row.cells.map(cell => cell.value),
        locations: row.cells.map(cell => cell.location)
      }))
    };
  }

  if (argument.type === 'DocString') {
    return argument.content;
  }

  return undefined;
}

function getTestParent(feature, scenario) {
  return `${feature.name || 'Undefined Feature'}: ${scenario.name || 'Undefined Scenario'}`;
}

function getTestStepTitle(keyword = '', text = '', type) {
  const title = !text && type !== 'hook' ? 'Undefined Step' : text;
  return `${keyword.trim()} ${title.trim()}`.trim();
}

function getTestFullTitle(parent, stepTitle) {
  return `${parent}: ${stepTitle}`;
}

function getUniqueIdentifier(target, sourceLocation) {
  if (target.type === 'Hook') {
    return `${path.basename(target.location.uri)}${target.location.line}`;
  }

  if (target.type === 'ScenarioOutline') {
    let name = target.name || target.text;
    const line = sourceLocation.line || '';

    if (Array.isArray(target.examples)) {
      target.examples.forEach(example => {
        example.tableHeader.cells.forEach((header, idx) => {
          if (name.indexOf('<' + header.value + '>') === -1) {
            return;
          }

          example.tableBody.forEach(tableEntry => {
            if (tableEntry.location.line === sourceLocation.line) {
              name = name.replace('<' + header.value + '>', tableEntry.cells[idx].value);
            }
          });
        });
      });
    }

    return `${name}${line}`;
  }

  const name = target.name || target.text;
  const location = target.location || target.locations[0];
  const line = location && location.line || '';
  return `${name}${line}`;
}

function formatMessage({
  payload = {}
}) {
  let content = _objectSpread({}, payload);

  if (payload.error && (payload.error.message || payload.error.stack)) {
    const {
      name,
      message,
      stack
    } = payload.error;
    content.error = {
      name,
      message,
      stack
    };
  }

  if (payload.title && payload.parent) {
    content.fullTitle = getTestFullTitle(payload.parent, payload.title);
  }

  return content;
}

function getStepType(type) {
  return type === 'Step' ? 'test' : 'hook';
}

function buildStepPayload(uri, feature, scenario, step, params = {}) {
  return _objectSpread({
    uid: getUniqueIdentifier(step),
    title: getTestStepTitle(step.keyword, step.text, params.type),
    parent: getTestParent(feature, scenario),
    argument: createStepArgument(step),
    file: uri,
    tags: scenario.tags,
    keyword: step.keyword,
    featureName: feature.name,
    scenarioName: scenario.name
  }, params);
}

function compareScenarioLineWithSourceLine(scenario, sourceLocation) {
  if (scenario.type.indexOf('ScenarioOutline') > -1) {
    return scenario.examples.some(example => example.tableBody.some(tableEntry => tableEntry.location.line === sourceLocation.line));
  }

  return scenario.location.line === sourceLocation.line;
}

const getDataFromResult = ([{
  uri
}, feature, ...scenarios]) => ({
  uri,
  feature,
  scenarios
});

exports.getDataFromResult = getDataFromResult;

function setUserHookNames(options) {
  _constants.CUCUMBER_HOOK_DEFINITION_TYPES.forEach(hookName => {
    options[hookName].forEach(testRunHookDefinition => {
      const hookFn = testRunHookDefinition.code;

      if (!hookFn.name.startsWith('wdioHook')) {
        const userHookAsyncFn = async function (...args) {
          return hookFn.apply(this, args);
        };

        const userHookFn = function (...args) {
          return hookFn.apply(this, args);
        };

        testRunHookDefinition.code = (0, _utils.isFunctionAsync)(hookFn) ? userHookAsyncFn : userHookFn;
      }
    });
  });
}

function getTestCaseSteps(feature, scenario, pickle, testCasePreparedEvent) {
  const allSteps = getAllSteps(feature, scenario);
  const steps = testCasePreparedEvent.steps.map(eventStep => {
    let step = allSteps.find(scenarioStep => {
      const location = scenarioStep.location || {};

      if (eventStep.sourceLocation && eventStep.sourceLocation.uri === testCasePreparedEvent.sourceLocation.uri) {
        return typeof location.uri === 'undefined' && eventStep.sourceLocation.line === location.line;
      }

      return eventStep.actionLocation.uri === location.uri && eventStep.actionLocation.line === location.line;
    });

    if (step && eventStep.sourceLocation) {
      step = enhanceStepWithPickleData(step, pickle);
    }

    return step ? step : {
      type: 'Hook',
      location: _objectSpread({}, eventStep.actionLocation),
      keyword: 'Hook',
      text: ''
    };
  });
  return steps;
}

function enhanceStepWithPickleData(origStep, pickle) {
  const step = _objectSpread({}, origStep);

  const pickleStep = pickle.steps.find(s => s.locations.some(loc => loc.line === step.location.line));

  if (pickleStep) {
    step.text = pickleStep.text;

    if (step.argument && step.argument.rows && Array.isArray(pickleStep.arguments)) {
      const pickleStepValueLocation = {};
      pickleStep.arguments.forEach(pStepArg => {
        pStepArg.rows.forEach(pStepRow => {
          pStepRow.cells.forEach(pStepCell => {
            if (!pickleStepValueLocation[pStepCell.location.line]) {
              pickleStepValueLocation[pStepCell.location.line] = {};
            }

            pickleStepValueLocation[pStepCell.location.line][pStepCell.location.column] = pStepCell.value;
          });
        });
      });
      step.argument.rows.forEach(stepRow => {
        stepRow.cells.forEach(stepCell => {
          stepCell.value = pickleStepValueLocation[stepCell.location.line][stepCell.location.column];
        });
      });
    }
  }

  return step;
}

function getAllSteps(feature, scenario) {
  const allSteps = [];
  const background = feature.children.find(child => child.type === 'Background');

  if (background) {
    allSteps.push(...background.steps);
  }

  allSteps.push(...scenario.steps);
  return allSteps;
}