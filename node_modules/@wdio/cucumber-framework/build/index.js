"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapterFactory = exports.CucumberAdapter = exports.default = void 0;

var Cucumber = _interopRequireWildcard(require("cucumber"));

var _mockery = _interopRequireDefault(require("mockery"));

var _isGlob = _interopRequireDefault(require("is-glob"));

var _glob = _interopRequireDefault(require("glob"));

var _path = _interopRequireDefault(require("path"));

var _reporter = _interopRequireDefault(require("./reporter"));

var _events = require("events");

var _utils = require("@wdio/utils");

var _constants = require("./constants");

var _utils2 = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class CucumberAdapter {
  constructor(cid, config, specs, capabilities, reporter) {
    this.cwd = process.cwd();
    this.cid = cid;
    this.specs = specs;
    this.reporter = reporter;
    this.capabilities = capabilities;
    this.config = config;
    this.cucumberOpts = Object.assign(_constants.DEFAULT_OPTS, config.cucumberOpts);
    this._hasTests = true;
    this.cucumberFeaturesWithLineNumbers = this.config.cucumberFeaturesWithLineNumbers || [];
    this.eventBroadcaster = new _events.EventEmitter();
  }

  async init() {
    try {
      const reporterOptions = {
        capabilities: this.capabilities,
        ignoreUndefinedDefinitions: Boolean(this.cucumberOpts.ignoreUndefinedDefinitions),
        failAmbiguousDefinitions: Boolean(this.cucumberOpts.failAmbiguousDefinitions),
        tagsInTitle: Boolean(this.cucumberOpts.tagsInTitle),
        scenarioLevelReporter: Boolean(this.cucumberOpts.scenarioLevelReporter)
      };
      this.cucumberReporter = new _reporter.default(this.eventBroadcaster, reporterOptions, this.cid, this.specs, this.reporter);
      const featurePathsToRun = this.cucumberFeaturesWithLineNumbers.length > 0 ? this.cucumberFeaturesWithLineNumbers : this.specs;
      const pickleFilter = new Cucumber.PickleFilter({
        featurePaths: featurePathsToRun,
        names: this.cucumberOpts.name,
        tagExpression: this.cucumberOpts.tagExpression
      });
      const eventBroadcasterProxyFilter = new _events.EventEmitter();
      this.eventBroadcaster.eventNames().forEach(n => eventBroadcasterProxyFilter.addListener(n, (...args) => (n !== 'pickle-accepted' || this.filter(args[0])) && this.eventBroadcaster.emit(n, ...args)));
      this.testCases = (await Cucumber.getTestCasesFromFilesystem({
        cwd: this.cwd,
        eventBroadcaster: eventBroadcasterProxyFilter,
        featurePaths: this.specs,
        order: this.cucumberOpts.order,
        pickleFilter
      })).filter(testCase => this.filter(testCase));
      this._hasTests = this.testCases.length > 0;
    } catch (runtimeError) {
      await (0, _utils.executeHooksWithArgs)(this.config.after, [runtimeError, this.capabilities, this.specs]);
      throw runtimeError;
    }

    return this;
  }

  hasTests() {
    return this._hasTests;
  }

  async run() {
    const {
      setOptions
    } = require('expect-webdriverio');

    setOptions({
      wait: this.config.waitforTimeout,
      interval: this.config.waitforInterval
    });
    let runtimeError;
    let result;

    try {
      var _context;

      this.registerRequiredModules();
      Cucumber.supportCodeLibraryBuilder.reset(this.cwd);
      this.addWdioHooks(this.config);
      this.loadSpecFiles();
      this.wrapSteps(this.config);
      (0, _utils2.setUserHookNames)(Cucumber.supportCodeLibraryBuilder.options);
      Cucumber.setDefaultTimeout(this.cucumberOpts.timeout);
      const supportCodeLibrary = Cucumber.supportCodeLibraryBuilder.finalize();
      this.getCurrentStep = (_context = this.cucumberReporter.eventListener).getCurrentStep.bind(_context);
      const runtime = new Cucumber.Runtime({
        eventBroadcaster: this.eventBroadcaster,
        options: this.cucumberOpts,
        supportCodeLibrary,
        testCases: this.testCases
      });
      result = (await runtime.start()) ? 0 : 1;

      if (this.cucumberOpts.ignoreUndefinedDefinitions && result) {
        result = this.cucumberReporter.failedCount;
      }
    } catch (e) {
      runtimeError = e;
      result = 1;
    }

    await (0, _utils.executeHooksWithArgs)(this.config.after, [runtimeError || result, this.capabilities, this.specs]);

    if (runtimeError) {
      throw runtimeError;
    }

    return result;
  }

  filter(testCase) {
    const skipTag = /^@skip\((.*)\)$/;

    const match = (value, expr) => {
      if (Array.isArray(expr)) {
        return expr.indexOf(value) >= 0;
      } else if (expr instanceof RegExp) {
        return expr.test(value);
      }

      return (expr && ('' + expr).toLowerCase()) === (value && ('' + value).toLowerCase());
    };

    const parse = skipExpr => skipExpr.split(';').reduce((acc, splitItem) => {
      const pos = splitItem.indexOf('=');

      if (pos > 0) {
        acc[splitItem.substring(0, pos)] = eval(splitItem.substring(pos + 1));
      }

      return acc;
    }, {});

    return !(testCase.pickle && testCase.pickle.tags && testCase.pickle.tags.map(p => p.name.match(skipTag)).filter(m => m).map(m => parse(m[1])).find(filter => Object.keys(filter).every(key => match(this.capabilities[key], filter[key]))));
  }

  registerRequiredModules() {
    this.cucumberOpts.requireModule.map(requiredModule => {
      if (Array.isArray(requiredModule)) {
        require(requiredModule[0])(requiredModule[1]);
      } else if (typeof requiredModule === 'function') {
        requiredModule();
      } else {
        require(requiredModule);
      }
    });
  }

  requiredFiles() {
    return this.cucumberOpts.require.reduce((files, requiredFile) => files.concat((0, _isGlob.default)(requiredFile) ? _glob.default.sync(requiredFile) : [requiredFile]), []);
  }

  loadSpecFiles() {
    _mockery.default.enable({
      useCleanCache: false,
      warnOnReplace: false,
      warnOnUnregistered: false
    });

    _mockery.default.registerMock('cucumber', Cucumber);

    this.requiredFiles().forEach(codePath => {
      const filepath = _path.default.isAbsolute(codePath) ? codePath : _path.default.join(process.cwd(), codePath);
      delete require.cache[require.resolve(filepath)];

      require(filepath);
    });

    _mockery.default.disable();
  }

  addWdioHooks(config) {
    Cucumber.Before(function wdioHookBeforeScenario({
      sourceLocation,
      pickle
    }) {
      const {
        uri,
        feature
      } = (0, _utils2.getDataFromResult)(global.result);
      return (0, _utils.executeHooksWithArgs)(config.beforeScenario, [uri, feature, pickle, sourceLocation]);
    });
    Cucumber.After(function wdioHookAfterScenario({
      sourceLocation,
      pickle,
      result
    }) {
      const {
        uri,
        feature
      } = (0, _utils2.getDataFromResult)(global.result);
      return (0, _utils.executeHooksWithArgs)(config.afterScenario, [uri, feature, pickle, result, sourceLocation]);
    });
    Cucumber.BeforeAll(function wdioHookBeforeFeature() {
      const {
        uri,
        feature,
        scenarios
      } = (0, _utils2.getDataFromResult)(global.result);
      return (0, _utils.executeHooksWithArgs)(config.beforeFeature, [uri, feature, scenarios]);
    });
    Cucumber.AfterAll(function wdioHookAfterFeature() {
      const {
        uri,
        feature,
        scenarios
      } = (0, _utils2.getDataFromResult)(global.result);
      return (0, _utils.executeHooksWithArgs)(config.afterFeature, [uri, feature, scenarios]);
    });
  }

  wrapSteps(config) {
    const wrapStep = this.wrapStep;
    const cid = this.cid;

    const getCurrentStep = () => this.getCurrentStep();

    Cucumber.setDefinitionFunctionWrapper((fn, options = {}) => {
      if (fn.name.startsWith('wdioHook')) {
        return fn;
      }

      const isStep = !fn.name.startsWith('userHook');
      const retryTest = isStep && isFinite(options.retry) ? parseInt(options.retry, 10) : 0;
      return wrapStep(fn, retryTest, isStep, config, cid, getCurrentStep);
    });
  }

  wrapStep(code, retryTest = 0, isStep, config, cid, getCurrentStep) {
    return function (...args) {
      const {
        uri,
        feature
      } = (0, _utils2.getDataFromResult)(global.result);
      const beforeFn = isStep ? config.beforeStep : config.beforeHook;
      const afterFn = isStep ? config.afterStep : config.afterHook;
      const hookParams = {
        uri,
        feature,
        step: getCurrentStep()
      };
      return _utils.testFnWrapper.call(this, isStep ? 'Step' : 'Hook', {
        specFn: code,
        specFnArgs: args
      }, {
        beforeFn,
        beforeFnArgs: context => [hookParams, context]
      }, {
        afterFn,
        afterFnArgs: context => [hookParams, context]
      }, cid, retryTest);
    };
  }

}

exports.CucumberAdapter = CucumberAdapter;
const _CucumberAdapter = CucumberAdapter;
const adapterFactory = {};
exports.adapterFactory = adapterFactory;

adapterFactory.init = async function (...args) {
  const adapter = new _CucumberAdapter(...args);
  const instance = await adapter.init();
  return instance;
};

var _default = adapterFactory;
exports.default = _default;