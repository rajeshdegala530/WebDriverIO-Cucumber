"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _cucumber = require("cucumber");

var _cucumberEventListener = _interopRequireDefault(require("./cucumberEventListener"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class CucumberReporter {
  constructor(eventBroadcaster, options, cid, specs, reporter) {
    _defineProperty(this, "gherkinDocEvents", []);

    this.capabilities = options.capabilities;
    this.tagsInTitle = options.tagsInTitle || false;
    this.options = options;
    this.cid = cid;
    this.specs = specs;
    this.reporter = reporter;
    this.failedCount = 0;
    this.scenarioLevelReport = options.scenarioLevelReporter;
    this.eventListener = new _cucumberEventListener.default(eventBroadcaster).on('before-feature', this.handleBeforeFeature.bind(this)).on('before-scenario', this.handleBeforeScenario.bind(this)).on('after-scenario', this.handleAfterScenario.bind(this)).on('after-feature', this.handleAfterFeature.bind(this));

    if (!this.scenarioLevelReport) {
      this.eventListener.on('before-step', this.handleBeforeStep.bind(this)).on('after-step', this.handleAfterStep.bind(this));
    }
  }

  handleBeforeFeature(uri, feature) {
    this.featureStart = new Date();
    this.emit('suite:start', {
      uid: (0, _utils.getUniqueIdentifier)(feature),
      title: this.getTitle(feature),
      type: 'feature',
      file: uri,
      tags: feature.tags,
      description: feature.description,
      keyword: feature.keyword
    });
  }

  handleBeforeScenario(uri, feature, scenario) {
    this.scenarioStart = new Date();
    this.testStart = new Date();
    this.emit(this.scenarioLevelReport ? 'test:start' : 'suite:start', {
      uid: (0, _utils.getUniqueIdentifier)(scenario),
      title: this.getTitle(scenario),
      parent: (0, _utils.getUniqueIdentifier)(feature),
      type: 'scenario',
      file: uri,
      tags: scenario.tags,
      description: scenario.description || feature.description
    });
  }

  handleBeforeStep(uri, feature, scenario, step) {
    this.testStart = new Date();
    const type = (0, _utils.getStepType)(step.type);
    const payload = (0, _utils.buildStepPayload)(uri, feature, scenario, step, {
      type
    });
    this.emit(`${type}:start`, payload);
  }

  handleAfterStep(uri, feature, scenario, step, result) {
    const type = (0, _utils.getStepType)(step.type);

    if (type === 'hook') {
      return this.afterHook(uri, feature, scenario, step, result);
    }

    return this.afterTest(uri, feature, scenario, step, result);
  }

  afterHook(uri, feature, scenario, step, result) {
    const payload = (0, _utils.buildStepPayload)(uri, feature, scenario, step, {
      type: 'hook',
      state: result.status,
      error: result.exception,
      duration: new Date() - this.testStart
    });
    this.emit('hook:end', payload);
  }

  afterTest(uri, feature, scenario, step, result, sourceLocation = null) {
    let state = 'undefined';

    switch (result.status) {
      case _cucumber.Status.FAILED:
      case _cucumber.Status.UNDEFINED:
        state = 'fail';
        break;

      case _cucumber.Status.PASSED:
        state = 'pass';
        break;

      case _cucumber.Status.PENDING:
      case _cucumber.Status.SKIPPED:
      case _cucumber.Status.AMBIGUOUS:
        state = 'pending';
    }

    let error = result.exception;
    let title = step ? (0, _utils.getTestStepTitle)(step.keyword, step.text) : this.getTitle(scenario);

    if (result.status === _cucumber.Status.UNDEFINED) {
      if (this.options.ignoreUndefinedDefinitions) {
        state = 'pending';
        title += ' (undefined step)';
      } else {
        this.failedCount++;
        error = {
          message: (step ? `Step "${title}" is not defined` : `Scenario ${title} has undefined steps`) + 'You can ignore this error by setting cucumberOpts.ignoreUndefinedDefinitions as true.',
          stack: step ? `${step.uri}:${step.line}` : `${scenario.uri}:${scenario.line}`
        };
      }
    } else if (result.status === _cucumber.Status.FAILED) {
      if (!result.retried) {
        this.failedCount++;
      }

      if (false === result.exception instanceof Error) {
        error = {
          message: result.exception,
          stack: ''
        };
      }
    } else if (result.status === _cucumber.Status.AMBIGUOUS && this.options.failAmbiguousDefinitions) {
      state = 'fail';
      this.failedCount++;
      error = {
        message: result.exception,
        stack: ''
      };
    }

    const common = {
      title: title,
      state,
      error,
      duration: new Date() - this.testStart,
      passed: state === 'pass',
      file: uri
    };
    const payload = step ? (0, _utils.buildStepPayload)(uri, feature, scenario, step, _objectSpread({
      type: 'step'
    }, common)) : _objectSpread({
      type: 'scenario',
      uid: (0, _utils.getUniqueIdentifier)(scenario, sourceLocation),
      parent: (0, _utils.getUniqueIdentifier)(feature),
      tags: scenario.tags
    }, common);
    this.emit('test:' + state, payload);
  }

  handleAfterScenario(uri, feature, scenario, result, sourceLocation) {
    if (this.scenarioLevelReport) {
      return this.afterTest(uri, feature, scenario, undefined, result, sourceLocation);
    }

    this.emit('suite:end', {
      uid: (0, _utils.getUniqueIdentifier)(scenario, sourceLocation),
      title: this.getTitle(scenario),
      parent: (0, _utils.getUniqueIdentifier)(feature),
      type: 'scenario',
      file: uri,
      duration: new Date() - this.scenarioStart,
      tags: scenario.tags
    });
  }

  handleAfterFeature(uri, feature) {
    this.emit('suite:end', {
      uid: (0, _utils.getUniqueIdentifier)(feature),
      title: this.getTitle(feature),
      type: 'feature',
      file: uri,
      duration: new Date() - this.featureStart,
      tags: feature.tags
    });
  }

  emit(event, payload) {
    let message = (0, _utils.formatMessage)({
      payload
    });
    message.cid = this.cid;
    message.specs = this.specs;
    message.uid = payload.uid;
    this.reporter.emit(event, message);
  }

  getTitle(featureOrScenario) {
    const name = featureOrScenario.name;
    const tags = featureOrScenario.tags;
    if (!this.tagsInTitle || !tags.length) return name;
    return `${tags.map(tag => tag.name).join(', ')}: ${name}`;
  }

}

var _default = CucumberReporter;
exports.default = _default;