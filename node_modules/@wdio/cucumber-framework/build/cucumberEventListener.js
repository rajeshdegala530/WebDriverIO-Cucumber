"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = require("events");

var _utils = require("./utils");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class CucumberEventListener extends _events.EventEmitter {
  constructor(eventBroadcaster) {
    super();

    _defineProperty(this, "gherkinDocEvents", []);

    _defineProperty(this, "acceptedPickles", []);

    _defineProperty(this, "currentPickle", null);

    _defineProperty(this, "currentStep", null);

    _defineProperty(this, "currentSteps", null);

    _defineProperty(this, "testCasePreparedEvents", []);

    eventBroadcaster.on('gherkin-document', this.onGherkinDocument.bind(this)).on('test-run-started', this.onTestRunStarted.bind(this)).on('pickle-accepted', this.onPickleAccepted.bind(this)).on('test-case-prepared', this.onTestCasePrepared.bind(this)).on('test-case-started', this.onTestCaseStarted.bind(this)).on('test-step-started', this.onTestStepStarted.bind(this)).on('test-step-finished', this.onTestStepFinished.bind(this)).on('test-case-finished', this.onTestCaseFinished.bind(this)).on('test-run-finished', this.onTestRunFinished.bind(this));
  }

  onGherkinDocument(gherkinDocEvent) {
    this.gherkinDocEvents.push(gherkinDocEvent);
  }

  onTestRunStarted() {
    const doc = this.gherkinDocEvents[this.gherkinDocEvents.length - 1];
    this.emit('before-feature', doc.uri, doc.document.feature);
  }

  onPickleAccepted(pickleEvent) {
    this.acceptedPickles.push(pickleEvent);
  }

  onTestCaseStarted(pickleEvent) {
    const {
      uri,
      pickle
    } = this.acceptedPickles.find(item => item.uri === pickleEvent.sourceLocation.uri && item.pickle.locations[0].line === pickleEvent.sourceLocation.line);
    const doc = this.gherkinDocEvents.find(gde => gde.uri === uri).document;
    const feature = doc.feature;
    this.currentPickle = pickle;
    const testCasePreparedEvent = this.testCasePreparedEvents[this.testCasePreparedEvents.length - 1];
    const scenario = feature.children.find(child => (0, _utils.compareScenarioLineWithSourceLine)(child, testCasePreparedEvent.sourceLocation));
    this.currentSteps = (0, _utils.getTestCaseSteps)(feature, scenario, pickle, testCasePreparedEvent);
    this.currentPickle.description = scenario.description;
    this.emit('before-scenario', uri, feature, this.currentPickle);
  }

  onTestStepStarted(testStepStartedEvent) {
    const sourceLocation = testStepStartedEvent.testCase.sourceLocation;
    const uri = sourceLocation.uri;
    const doc = this.gherkinDocEvents.find(gde => gde.uri === uri).document;
    const feature = doc.feature;
    const scenario = feature.children.find(child => (0, _utils.compareScenarioLineWithSourceLine)(child, sourceLocation));
    const step = this.currentSteps[testStepStartedEvent.index];

    if (step.type === 'Step') {
      this.currentStep = {
        uri,
        feature,
        scenario,
        step,
        sourceLocation
      };
    }

    this.emit('before-step', uri, feature, scenario, step, sourceLocation);
  }

  onTestCasePrepared(testCasePreparedEvent) {
    this.testCasePreparedEvents.push(testCasePreparedEvent);
    const sourceLocation = testCasePreparedEvent.sourceLocation;
    const uri = sourceLocation.uri;
    const doc = this.gherkinDocEvents.find(gde => gde.uri === uri).document;
    const scenario = doc.feature.children.find(child => (0, _utils.compareScenarioLineWithSourceLine)(child, sourceLocation));
    const hasScenarioHasHooks = scenario.steps.filter(step => step.type === 'Hook').length > 0;

    if (hasScenarioHasHooks) {
      return;
    }

    const allSteps = testCasePreparedEvent.steps;
    allSteps.forEach((step, idx) => {
      if (step.sourceLocation) {
        return;
      }

      step.sourceLocation = {
        line: step.actionLocation.line,
        column: 0,
        uri: step.actionLocation.uri
      };
      const hook = {
        type: 'Hook',
        location: step.sourceLocation,
        keyword: 'Hook',
        text: ''
      };
      scenario.steps.splice(idx, 0, hook);
    });
  }

  onTestStepFinished(testStepFinishedEvent) {
    const sourceLocation = testStepFinishedEvent.testCase.sourceLocation;
    const uri = sourceLocation.uri;
    const doc = this.gherkinDocEvents.find(gde => gde.uri === uri).document;
    const feature = doc.feature;
    const scenario = feature.children.find(child => (0, _utils.compareScenarioLineWithSourceLine)(child, sourceLocation));
    const step = this.currentSteps[testStepFinishedEvent.index];
    const result = testStepFinishedEvent.result;
    this.emit('after-step', uri, feature, scenario, step, result, sourceLocation);
  }

  onTestCaseFinished(testCaseFinishedEvent) {
    const {
      sourceLocation,
      result
    } = testCaseFinishedEvent;
    const uri = sourceLocation.uri;
    const doc = this.gherkinDocEvents.find(gde => gde.uri === uri).document;
    const feature = doc.feature;
    const scenario = feature.children.find(child => (0, _utils.compareScenarioLineWithSourceLine)(child, sourceLocation));
    this.emit('after-scenario', uri, feature, scenario, result, sourceLocation);
    this.currentPickle = null;
    this.currentStep = null;
    this.currentSteps = null;
  }

  onTestRunFinished() {
    const gherkinDocEvent = this.gherkinDocEvents.pop();
    const uri = gherkinDocEvent.uri;
    const doc = gherkinDocEvent.document;
    const feature = doc.feature;
    this.emit('after-feature', uri, feature);
  }

  getCurrentStep() {
    return this.currentStep;
  }

}

exports.default = CucumberEventListener;